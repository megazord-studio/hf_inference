{% extends "base.html" %}
{% block title %}HF Model Arcade{% endblock %}
{% block extra_head %}
<link rel="stylesheet" href="https://unpkg.com/@shoelace-style/shoelace@2.15.1/cdn/themes/dark.css" />
<script type="module" src="https://unpkg.com/@shoelace-style/shoelace@2.15.1/cdn/shoelace-autoloader.js"></script>
<script src="https://unpkg.com/clusterize.js@0.18.1/clusterize.min.js"></script>
{% endblock %}
{% block body %}
<div class="page-grid"></div>

<div class="container">
  <div class="header-bar">
    <div>
      <h1>HF Model Arcade</h1>
      <p class="tagline">A zero‑calorie buffet of models. Pick a task, filter like you’re grepping prod logs, sort columns, or smash <strong>Neon Pulse</strong> to get a questionable yet entertaining popularity score. Export to CSV and automate the boring parts.</p>
    </div>
    <a href="/logout" class="logout-btn" title="Yeet the cookie and bounce">Log out</a>
  </div>

  <form id="panelForm" class="panel" data-selected-task="{{ task or '' }}" data-tasks='{{ tasks | tojson | safe }}'>
    <div>
      <label for="task" class="muted">Task (wired up)</label>
      <select id="task" name="task" onchange="location.href='/?task=' + encodeURIComponent(this.value)">
        <option value="">(choose a task)</option>
        {% for t in tasks %}
        <option value="{{ t }}" {% if task == t %}selected{% endif %}>{{ t }}</option>
        {% endfor %}
      </select>
    </div>

    {% if task and not invalid_task %}
    <div class="card">
      <div class="toolbar">
        <input id="q" placeholder="Greppish filter (e.g. llama)" style="flex:2" />
        <select id="gatedSel" style="flex:1" title="Filter by gating (open/gated/manual)"></select>
        <button id="neonSort" type="button" class="neon-btn" title="Sort by spicy composite signal">⚡ Neon&nbsp;Pulse</button>
        <div class="spacer"></div>
        <sl-button id="downloadCsv" size="small" outline title="Ship it to your notebook">Export CSV</sl-button>
      </div>
      <div class="toolbar" style="padding-top:0; gap:0">
        <div id="count" class="muted"></div>
      </div>

      <div id="spinner" class="muted">Summoning a ridiculous amount of models…</div>
      <div class="table-wrap">
        <table>
          <thead>
          <tr>
            <th class="sortable" data-key="id" style="width:46%">
              <span class="label">Model <span class="sort-icon">▲</span></span>
            </th>
            <th class="sortable" data-key="gated" style="width:12%">
              <span class="label">Gated <span class="sort-icon">▲</span></span>
            </th>
            <th class="sortable" data-key="downloads" style="width:12%; text-align:right">
              <span class="label">Downloads <span class="sort-icon">▲</span></span>
            </th>
            <th class="sortable" data-key="likes" style="width:12%; text-align:right">
              <span class="label">Likes <span class="sort-icon">▲</span></span>
            </th>
            <th class="sortable" data-key="trendingScore" style="width:12%; text-align:right">
              <span class="label">Trend‑ish <span class="sort-icon">▲</span></span>
            </th>
            <th class="run-col" style="width:8%; text-align:center">
              <span class="label">Run</span>
            </th>
          </tr>
          </thead>
        </table>
        <div id="scrollArea" style="height:calc(70vh - 44px); overflow:auto;">
          <table>
            <tbody id="contentArea"></tbody>
          </table>
        </div>
      </div>
    </div>
    {% else %}
    <div class="card note">
      {% if invalid_task %}
      <h2>Unsupported task</h2>
      <p>Task “{{ task }}” isn’t wired here. Pick one from the menu like a civilized engineer.</p>
      {% else %}
      <h2>Pick a Task ↑</h2>
      <p>Choose a pipeline and we’ll shovel in a very large JSON so your browser can do what browsers do best: index things and pretend it’s a database.</p>
      <p>• Substring filter like a pro.<br/>
        • Flip the gated filter once data lands.<br/>
        • Click headers to sort (asc/desc).<br/>
        • Tap <strong>Neon Pulse</strong> for vibes‑based ranking (downloads/likes/trend).<br/>
        • Export the current view to CSV and script away.</p>
      <p>Zero ML “magic” here. Just ergonomics so you can locate your next yak to shave.</p>
      {% endif %}
    </div>
    {% endif %}
  </form>
</div>

<sl-dialog id="runDialog" class="run-dialog" label="Run model"></sl-dialog>

{% include "inference_modal.html" %}

<script>
(async function(){
  const formEl = document.getElementById('panelForm');
  const task = new URLSearchParams(location.search).get('task') || (formEl ? formEl.dataset.selectedTask : '') || '';

  window.__HF_MODELS_PAGE_CONTEXT = window.__HF_MODELS_PAGE_CONTEXT || {};
  window.__HF_MODELS_PAGE_CONTEXT.selectedTask = task;
  let allTasks = [];
  if (formEl && formEl.dataset.tasks) {
    try {
      allTasks = JSON.parse(formEl.dataset.tasks);
    } catch (e) {
      allTasks = [];
    }
  }
  window.__HF_MODELS_PAGE_CONTEXT.tasks = allTasks;

  const q = document.getElementById('q');
  const gatedSel = document.getElementById('gatedSel');
  const neonBtn = document.getElementById('neonSort');
  const countEl = document.getElementById('count');
  const spinner = document.getElementById('spinner');
  const contentArea = document.getElementById('contentArea');
  const scrollArea = document.getElementById('scrollArea');
  const dlCsvBtn = document.getElementById('downloadCsv');

  const thModel = document.querySelector('th[data-key="id"]');
  const thGated = document.querySelector('th[data-key="gated"]');
  const thDl    = document.querySelector('th[data-key="downloads"]');
  const thLikes = document.querySelector('th[data-key="likes"]');
  const thTrend = document.querySelector('th[data-key="trendingScore"]');

  if (formEl) formEl.addEventListener('submit', (e) => e.preventDefault());
  if (q) q.addEventListener('keydown', (e) => { if (e.key === 'Enter') e.preventDefault(); });

  if(!task || !contentArea) return;

  const workerSrc = `
    let ALL = [];
    function safeMax(rows, getter, minVal=1){
      let max = minVal;
      for (let i=0;i<rows.length;i++){ const v = getter(rows[i]); if (v>max) max=v; }
      return max;
    }
    function neonScoreFactory(rows){
      const maxLogD = safeMax(rows, r => Math.log1p(r.downloads||0), 1);
      const maxLikes = safeMax(rows, r => (r.likes||0), 1);
      const maxTrend = safeMax(rows, r => (r.trendingScore||0), 1);
      return (r) => {
        const nd=Math.log1p(r.downloads||0)/maxLogD;
        const nl=(r.likes||0)/maxLikes;
        const nt=(r.trendingScore||0)/maxTrend;
        return 0.5*nd + 0.3*nl + 0.2*nt;
      };
    }
    function cmp(a,b){ return a<b ? -1 : a>b ? 1 : 0; }
    onmessage = (e) => {
      const {type, payload} = e.data || {};
      if(type === 'set'){
        ALL = payload || [];
        const gatedValues = Array.from(new Set(ALL.map(r => (r.gated||'false') + ''))).sort();
        postMessage({type:'ready', total: ALL.length, gatedValues});
        return;
      }
      if(type === 'query'){
        const { term, gated, neon, sortKey, sortDir } = payload;
        let base = ALL;
        if(gated){ base = base.filter(r => String(r.gated) === gated); }
        if(term){
          const t = term.toLowerCase();
          base = base.filter(r => (r.id||'').toLowerCase().includes(t));
        }
        if(neon){
          const score = neonScoreFactory(base);
          base = base.slice().sort((a,b) => score(b) - score(a));
        } else if (sortKey){
          const dir = (sortDir === 'asc') ? 1 : -1;
          base = base.slice().sort((a,b) => {
            const va = (sortKey==='id'||sortKey==='gated') ? (String(a[sortKey]||'')) : Number(a[sortKey]||0);
            const vb = (sortKey==='id'||sortKey==='gated') ? (String(b[sortKey]||'')) : Number(b[sortKey]||0);
            return dir * cmp(va,vb);
          });
        }
        postMessage({type:'result', rows: base});
      }
      if(type === 'csv'){
        const rows = payload || ALL;
        const head = ['id','gated','downloads','likes','trendingScore'];
        const esc = (s) => '"' + String(s).replaceAll('"','""') + '"';
        const lines = [head.join(',')].concat(
          rows.map(r => [r.id, r.gated, r.downloads||0, r.likes||0, r.trendingScore||0].map(esc).join(','))
        );
        postMessage({type:'csv', csv: lines.join('\\n')});
      }
    };
  `;
  const blob = new Blob([workerSrc], {type:'application/javascript'});
  const worker = new Worker(URL.createObjectURL(blob));

  const clusterize = new Clusterize({
    rows: [],
    scrollElem: scrollArea,
    contentElem: contentArea,
    rows_in_block: 60,
    blocks_in_cluster: 4,
    no_data_text: 'No data (wrong timeline?)',
    tag: 'tr'
  });

  // dialog + external sub-template wiring
  const dlg = document.getElementById('runDialog');

  // ensure dialog sits under <body>, then wait until it's fully defined
  if (dlg && dlg.parentElement !== document.body) document.body.appendChild(dlg);
  if (window.customElements && customElements.whenDefined) {
    await customElements.whenDefined('sl-dialog');
  }

  function rowHtml(r){
    const link = '<span class="link"><a href="https://huggingface.co/' + r.id + '" target="_blank" title="' + r.id + '">' + r.id + '</a></span>';
    let chip = '<span class="chip chip-false">open</span>';
    if(r.gated === 'true') chip = '<span class="chip chip-true">gated</span>';
    if(r.gated === 'manual') chip = '<span class="chip chip-manual">manual</span>';
    const fmt = (v) => (Number(v||0)).toLocaleString('en-US');

    const runBtn =
      '<div class="cell-run">' +
      '<button class="neon-run" title="Run this model" onclick="runModel(\'' +
      r.id.replace(/'/g, "\\'") +
      '\')">' +
      '<span class="neon-run__icon">▶</span>' +
      '<span class="neon-run__label">RUN</span>' +
      '</button>' +
      '</div>';

    return '<tr>'
      + '<td style="width:46%">' + link + '</td>'
      + '<td style="width:12%">' + chip + '</td>'
      + '<td class="num" style="width:12%">' + fmt(r.downloads) + '</td>'
      + '<td class="num" style="width:12%">' + fmt(r.likes) + '</td>'
      + '<td class="num" style="width:12%">' + fmt(r.trendingScore) + '</td>'
      + '<td class="run-cell" style="width:8%">' + runBtn + '</td>'
      + '</tr>';
  }

  let neonActive = false;
  let currentRows = [];
  let sortKey = null;
  let sortDir = 'desc';

  function applySortHeaderStyles(){
    const headers = [thModel, thGated, thDl, thLikes, thTrend].filter(Boolean);
    headers.forEach(th => th.classList.remove('sort-asc','sort-desc'));
    if (!sortKey) return;
    const th = document.querySelector('th[data-key="'+sortKey+'"]');
    if (th) th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
  }

  function refresh(){
    worker.postMessage({
      type:'query',
      payload:{
        term: (q && q.value && q.value.trim()) || '',
        gated: (gatedSel && gatedSel.value) || '',
        neon: neonActive,
        sortKey,
        sortDir
      }
    });
    applySortHeaderStyles();
  }

  worker.onmessage = (e) => {
    const {type} = e.data || {};
    if(type === 'ready'){
      if (spinner) spinner.textContent = '';
      const { total, gatedValues } = e.data;
      if (countEl) countEl.textContent = total.toLocaleString('en-US') + ' total';
      const opts = ['<option value="">gated: any</option>'].concat((gatedValues||[]).map(v => '<option value="' + v + '">' + v + '</option>'));
      if(gatedSel) gatedSel.innerHTML = opts.join('');
      refresh(); return;
    }
    if(type === 'result'){
      const rows = e.data.rows || [];
      currentRows = rows;
      if (countEl) countEl.textContent = rows.length.toLocaleString('en-US') + ' shown';
      clusterize.update(rows.map(r => rowHtml(r)));
      return;
    }
    if(type === 'csv'){
      const url = URL.createObjectURL(new Blob([e.data.csv || ''], {type:'text/csv'}));
      const a = document.createElement('a');
      a.href = url;
      a.download = (task || 'models') + '.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
    }
  };

  try{
    const res = await fetch('/models?task=' + encodeURIComponent(task));
    const data = await res.json();
    if (!res.ok) {
      const parts = [];
      if (data && typeof data === 'object') {
        if (data.reason) parts.push(String(data.reason));
        else if (data.error) parts.push(String(data.error));
        else if (data.detail) parts.push(String(data.detail));
        if (data.hint) parts.push(String(data.hint));
      }
      if (parts.length === 0) parts.push('Hugging Face models failed to load.');
      if (spinner) spinner.textContent = parts.join(' ');
      return;
    }
    if (!Array.isArray(data)) {
      if (spinner) spinner.textContent = 'No data for this task (did you summon the right pipeline?)';
      return;
    }
    const cacheState = res.headers.get('X-HF-Cache');
    if (spinner) {
      spinner.textContent = cacheState === 'stale'
        ? 'Showing cached models while Hugging Face cools down (' + data.length.toLocaleString('en-US') + ' models).'
        : 'Loaded ' + data.length.toLocaleString('en-US') + ' models. Your tab survives. Probably.';
    }
    const rows = data.map(r => ({
      id: r.id,
      downloads: Number(r.downloads||0),
      likes: Number(r.likes||0),
      trendingScore: Number(r.trendingScore||0),
      gated: (function(g){ if (typeof g === 'string' && g.trim()) return g.trim(); return g ? 'true' : 'false'; })(r.gated)
    }));
    worker.postMessage({type:'set', payload: rows});
  } catch(err){
    if (spinner) spinner.textContent = 'Network gremlins. Could not load models.';
    console.error(err);
  }

  let t = null;
  if(q){ q.addEventListener('input', () => { clearTimeout(t); t = setTimeout(refresh, 150); }); }
  if(gatedSel){ gatedSel.addEventListener('change', refresh); }
  if(neonBtn){
    neonBtn.addEventListener('click', () => {
      neonActive = !neonActive;
      if (neonActive) sortKey = null;
      neonBtn.classList.toggle('is-active', neonActive);
      refresh();
    });
  }
  if(dlCsvBtn){ dlCsvBtn.addEventListener('click', () => worker.postMessage({type:'csv', payload: currentRows})); }

  [thModel, thGated, thDl, thLikes, thTrend].filter(Boolean).forEach(th => {
    th.addEventListener('click', () => {
      const key = th.getAttribute('data-key'); if (!key) return;
      neonActive = false;
      if (sortKey === key) sortDir = (sortDir === 'asc') ? 'desc' : 'asc';
      else { sortKey = key; sortDir = (key === 'id' || key === 'gated') ? 'asc' : 'desc'; }
      neonBtn && neonBtn.classList.remove('is-active');
      refresh();
    });
  });
})();
</script>
<script src="/static/js/inference.js"></script>
{% endblock %}
